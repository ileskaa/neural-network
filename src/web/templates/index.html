<!doctype html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Digit Recognizer</title>
  <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='network.svg') }}">
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <!-- Get some fonts -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap');
  </style>
</head>

<div id="header">
  <h1>Draw a Digit!</h1>
</div>

<canvas id="square" width="280" height="280"></canvas>

<button class="reset">Reset</button>

<button class="submit">Submit</button>

<div id="prediction"></div>

<div id="pre-processed" style="margin-top: 10px;"></div>

<script>
  const body = document.getElementsByTagName('body')[0]
  const canvas = document.getElementById('square')
  const ctx = canvas.getContext('2d')
  ctx.lineWidth = 20
  ctx.lineCap = 'round'

  let drawing = false

  function getPos(event) {
    if (event.touches) {
      const rect = canvas.getBoundingClientRect()
      return {
        // Touch event coordinates are initially relative to the viewport,
        // so we need to do some math
        x: event.touches[0].clientX - rect.left,
        y: event.touches[0].clientY - rect.top
      }
    }
    return {
      x: event.offsetX,
      y: event.offsetY
    }
  }

  function startDrawing(event) {
    event.preventDefault()
    drawing = true
    ctx.beginPath()
    const pos = getPos(event)
    // Begin a new sub-path at the specified point
    ctx.moveTo(pos.x, pos.y)
  }

  function draw(event) {
    if (!drawing)
      return
    const pos = getPos(event)
    // Add a straight line to the current sub-path by connecting the sub-path's
    // last point to the specified coordinate
    ctx.lineTo(pos.x, pos.y)
    // Outline the current path with the current storke style
    ctx.stroke()
  }

  function displayPixels(pixels) {
    const displayCanvas = document.createElement('canvas')
    displayCanvas.width = displayCanvas.height = 28

    const displayCtx = displayCanvas.getContext('2d')
    // Create a blank ImageData object
    const imageData = displayCtx.createImageData(28, 28)

    // Fill imageData with pixel values
    for (let i = 0; i < pixels.length; i++) {
      const pixelValue = pixels[i]
      // Multiply by 4 since every pixel has 4 values (RGBA)
      const startIndex = i * 4

      // Since we are working in grayscale, we can set R,G and B to the same value
      imageData.data[startIndex] = pixelValue     // R
      imageData.data[startIndex + 1] = pixelValue // G
      imageData.data[startIndex + 2] = pixelValue // B
      imageData.data[startIndex + 3] = 255        // A (no transparency)
    }

    // Paint data from ImageData object onto the canvas
    displayCtx.putImageData(imageData, 0, 0)

    const div = document.getElementById('pre-processed')
    // Clear container to avoid stacking canvases
    div.innerHTML = ''
    div.appendChild(displayCanvas)
  }

  function getGrayscalePixels(canvas) {
    const smallCanvas = document.createElement('canvas')
    const size = 28
    smallCanvas.width = smallCanvas.height = size
    const smallCtx = smallCanvas.getContext('2d')

    // By default the canvas has no background. It is transparent.
    // But MNIST consists of white strokes on black backgrounds.
    // We therefore set a white background, so that we can later invert it to black
    smallCtx.fillStyle = 'white'
    smallCtx.fillRect(0, 0, size, size)

    // Every pixel now has RGB values of 255, since every pixel is white.
    // Each pixel alpha is also 255, since we don't have transparent pixels anymore.

    smallCtx.drawImage(canvas, 0, 0, size, size)
    const smallImageData = smallCtx.getImageData(
      0, 0, size, size
    )
    // The data property represents a 1D array containg the data in RGBA order.
    // The order goes by rows from the top-left pixel to the bottom-right
    const data = smallImageData.data

    const pixels = []

    for (let i = 0; i < data.length; i += 4) {
      // Since we are only drawing in black, RGB values will always be 0.
      // Only the alpha value will be above 0.
      const r = data[i]
      const g = data[i + 1]
      const b = data[i + 2]
      const a = data[i + 3]

      // According to W3C, this formula can be used to determine color brightness
      const brightness = r * 0.299 + g * 0.587 + b * 0.114

      // Turn the background to black and the strokes to white (or at least whitish)
      const inverted = 255 - brightness

      pixels.push(inverted)
    }

    displayPixels(pixels)

    return pixels
  }

  function stopDrawing(event) {
    drawing = false
    ctx.closePath()
  }

  canvas.addEventListener('mousedown', startDrawing)
  canvas.addEventListener('mousemove', draw)
  // We attach this listener to the body since we wanna be able to stop drawing
  // no matter where the mouse is
  body.addEventListener('mouseup', stopDrawing)

  canvas.addEventListener('touchstart', startDrawing)
  canvas.addEventListener('touchmove', draw)
  canvas.addEventListener('touchend', stopDrawing)

  const resetButton = document.getElementsByClassName('reset')[0]
  const submitButton = document.getElementsByClassName('submit')[0]

  function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height)
  }

  async function getPrediction() {
    const pixels = getGrayscalePixels(canvas)

    const result = await fetch('/predict', {
      method: 'POST',
      body: JSON.stringify({ digit: pixels }),
      headers: { "Content-type": "application/json" }
    })
    const data = await result.json()
    pred = data['prediction']

    const predElement = document.getElementById('prediction')
    predElement.innerText = pred

    clearCanvas()
  }

  resetButton.addEventListener('click', clearCanvas)
  submitButton.addEventListener('click', getPrediction)
</script>